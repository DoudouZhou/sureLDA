
R version 3.6.1 (2019-07-05) -- "Action of the Toes"
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> library(bindata) ##For Multiple Y
> 
> Simulate<-function(N=10000,K=10,M=50){
+   ##Generate Paramters
+   Alpha <- rep(0.3,K)
+   Beta <- rep(0.25,K)
+   Lambda <- matrix(rep(0.2,M*K-2*K))
+   
+   mu_positive <- rbind(
+     t(sapply(1:5,function(o) c(4.5,2.1,seq(1.9,1.7,length=M-2)))),
+     t(sapply(6:K,function(o) c(4.5,2.1,seq(1.9,1.7,length=M-2)))) )
+   mu_negative <- rbind(
+     t(sapply(1:5,function(o) c(0.51,0.81,seq(0.85,0.82,length=M-2)))),
+     t(sapply(6:K,function(o) c(0.51,0.81,seq(0.85,0.81,length=M-2)))) )
+   
+   ##Prior Probability of Y
+   Pi <- c(0.4,0.2,0.15,0.13,0.1,0.03,0.03,0.03,0.03,0.03)
+   
+   ##Correlation of Multiple Y
+   sigma <- matrix(0, K, K)
+   sigma[1,2] <- 0.5
+   sigma[2,1] <- 0.5
+   diag(sigma)<-1
+   ##Generate Y
+   Y <- rmvbin(N, margprob=Pi, sigma=sigma)
+   Y_table = apply(Y,1,function(x){t(2^(0:(K-1)))%*%t(t(x))})
+   table(Y_table)
+   length(table(Y_table))
+   
+   ##Generate X
+   H <- rpois(N,lambda = 2)
+   random <- t(apply(Y,1,function(y){
+     t(sapply(1:K, function(i){
+       yi = y[i]
+       if(yi==1) rgamma(M, scale=mu_positive[i,], shape=1)
+       else rgamma(M, scale=mu_negative[i,], shape=1)
+     }))
+   }))
+   
+   logX <- cbind(log(H+1)%*%t(Alpha),log(H+1)%*%t(Beta),log(H+1)%*%t(Lambda)) + log(random)
+   X <- floor(exp(logX))
+   ICD <- X[,1:K] 
+   X <- cbind(H,X)
+   colnames(X) <- c('H',paste('ICD',1:K,sep=''),paste('NLP',1:K,sep=''),paste('V',1:(M*K-2*K),sep=''))
+   ##Filter is defined as ICD >= 1
+   filter <- I(ICD>=1)*1
+   
+   i = 1
+   for(i in 1:K){
+     print(table(filter[,i],Y[,i],dnn=c(paste('filter',i,sep=''),paste('Diseases',i,sep='')))/N)
+   }
+   list(X=X,Y=Y,filter=filter)
+ }
> 
> 
> set.seed(123)
> N=1000  ##Number of patients
> K=10     ##Number of diseases
> M=50     ##Number of features for each diseases, two of them are ICD and NLP.
> Sim <- Simulate(N,K,M)
       Diseases1
filter1     0     1
      0 0.470 0.047
      1 0.134 0.349
       Diseases2
filter2     0     1
      0 0.618 0.025
      1 0.186 0.171
       Diseases3
filter3     0     1
      0 0.663 0.014
      1 0.197 0.126
       Diseases4
filter4     0     1
      0 0.655 0.014
      1 0.201 0.130
       Diseases5
filter5     0     1
      0 0.693 0.018
      1 0.218 0.071
       Diseases6
filter6     0     1
      0 0.739 0.002
      1 0.229 0.030
       Diseases7
filter7     0     1
      0 0.783 0.004
      1 0.188 0.025
       Diseases8
filter8     0     1
      0 0.767 0.001
      1 0.209 0.023
       Diseases9
filter9     0     1
      0 0.756 0.003
      1 0.211 0.030
        Diseases10
filter10     0     1
       0 0.741 0.007
       1 0.229 0.023
> X <- Sim$X[,-1]
> Y <- Sim$Y
> filter <-Sim$filter 
> diseases <- seq(K)
> HU <- Sim$X[,1]
> ICD <- Sim$X[,2:11]
> NLP <- Sim$X[,12:21]
> nPatients = N
> weight <- matrix(1,K*M,K)
> 
> L <- list(X = X, weight = weight, ICD = ICD, NLP = NLP, HU = HU, filter = filter)
> str(L)
List of 6
 $ X     : num [1:1000, 1:500] 1 3 0 5 0 0 0 0 1 1 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : NULL
  .. ..$ : chr [1:500] "ICD1" "ICD2" "ICD3" "ICD4" ...
 $ weight: num [1:500, 1:10] 1 1 1 1 1 1 1 1 1 1 ...
 $ ICD   : num [1:1000, 1:10] 1 3 0 5 0 0 0 0 1 1 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : NULL
  .. ..$ : chr [1:10] "ICD1" "ICD2" "ICD3" "ICD4" ...
 $ NLP   : num [1:1000, 1:10] 0 11 0 1 1 0 0 0 0 2 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : NULL
  .. ..$ : chr [1:10] "NLP1" "NLP2" "NLP3" "NLP4" ...
 $ HU    : num [1:1000] 6 1 2 1 3 1 1 2 2 2 ...
 $ filter: 'AsIs' num [1:1000, 1:10] 1 1 0 1 0 0 0 0 1 1 ...
> 
> saveRDS(L, "simdata.rds")
> 
> proc.time()
   user  system elapsed 
  0.619   0.060   0.670 
